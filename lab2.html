<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Courteney Zboyan <br />
      2/1/25
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
	Module 2

		This lab report explores the Random Walk Function, the Koch Snowflake, and the Dragon Curve.
		Sample code is provided and then experimental code is made.
		What the code does will be outlined.
		
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
	
		Sample Code Set #1: Random Walk Function
		-This code imports a custom turtle library to use various turtle functions. 
		-At first, the code did not work because the command was non-standard, so this had to be imported.
		-Random import allows us to use various random functions later on.
		-The canvas is initialized with width of 1000 and height of 800
		-The random walk function is defined.
		-The jump and penup command moves the start to 450x450
		-A loop is used to repeat the functions 1000 times (steps) with distance of 10 pixels (step length).
		-The result is then displayed. I ran the code twice, to verify the random-ness.

		See Images:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture1.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/picture2.png" alt="See the Image" />
		
		See code below:

#Sample Code Set 1 (intact as you gave, besides for one fix and some comments)
import random

# This code installs the turtle library
!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *
#At first, the code did NOT work. Upon analyzing the error, I went back and grabbed this above code from Module 1

# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
#the canvass width is set to 1000 by 800 pixels
#initially, the code did NOT work before the Hahn turtle library was stated as the "initialize turtle" is non-standard

# Step 2: Function to perform a random walk (Brownian motion)
#The random walk function is something I recognize from Statistics class of "Time Series" 
def random_walk(steps, step_length):
    speed(0)             # Set speed to maximum for faster drawing
    penup()               #raises pen to move it
    jump(450, 450)       # Start near the middle of the canvas
    pendown()             #puts pen down to draw

    for _ in range(steps):
        forward(step_length)               # Move forward by the step length
        right(random.uniform(-180, 180))   # Turn by a random angle between -180 and 180 degrees

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10

random_walk(steps, step_length)

# Step 4: Display the result
show()
		
 </p>
 </p>
		
		Experimental Code Set 1A: Altering the Random Walk Code:
		Some adjustments were made to the original code, namely:
		-A black background 
		-Use of a random vibrant color for each step, from a predetermined list of 8 colors

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture3.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1A (black background, varying random vibrant colors)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(450, 450)  # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color
        forward(step_length)  # Move forward by the step length
        right(random.uniform(-180, 180))  # Turn by a random angle

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10
random_walk(steps, step_length)

# Step 4: Display the result with the goal of eye popping design
show()		#This looks like an animal with a tail and short limbs!

 </p>
 </p>
		
		Experimental Code Set 1B: More altering the Random Walk Code:
		Some more adjustments were made to the previous code, namely:
		-a reduced canvas size of 500x400
		-adjusted start to 250x250
		-increased steps to 2000 and decresed step length to 5
		

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture4.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1B (more steps, smaller length)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
#I reduced canvas width

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(250, 250)  # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color
        forward(step_length)  # Move forward by the step length
        right(random.uniform(-180, 180))  # Turn by a random angle

# Step 3: Execute the random walk with 2000 steps and/or step length of 5 now
steps = 2000
step_length = 5
random_walk(steps, step_length)

# Step 4: Display the result with the goal of eye popping design that fit on a smaller canvas
show()
		
 </p>
 </p>
		
		Experimental Code Set 1C: More altering the Random Walk Code:
		Some more adjustments were made to the previous code, namely:
		-a varying step size from a random selection of 4 odd numbers: 3, 5, 7, or 9
		-if/else loop to sometimes reflect the turtle motion, creating a mirrored pattern

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture5.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1C (varying step size)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk with varying step lengths and symmetry
def random_walk(steps, step_lengths):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(250, 200)  # Start near the center of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color

        # Varying step length
        step_length = random.choice(step_lengths)  # Pick a random step size
        forward(step_length)  # Move forward by the step length

        # Symmetry: Reflect the movement across the vertical axis
        if random.choice([True, False]):
            left(180)  # Turn by 180 degrees (reflecting horizontally)

        right(random.uniform(-180, 180))  # Random turn to maintain randomness

# Step 3: Execute the random walk with varying step lengths and 2000 steps
steps = 2000
step_lengths = [3, 5, 7, 9]  # 4 Different possible step lengths
random_walk(steps, step_lengths)

# Step 4: Display the result with these new features
show()
		
 </p>
 </p>
		
		Sample Code Set 2: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-First, the canvas is initialized
		-The start is set at 50x400 and the turtle faces up (90 degrees).
		-A blip/zig zag bump is then drawn in a horizontal line using a 60 CCW, 120 CW, 60 CCW degree rotation
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture6.png" alt="See the Image" />
		
		See code below:

#Sample Code Set #2 (what you gave us)
initializeTurtle()
showturtle()

jump(50, 400)
face(90)

# Line with blip
forward(800 / 3)
left(60) 
forward(800 / 3)
right(120)
forward(800 / 3)
left(60)
forward(800 / 3)

show()

 </p>
 </p>
		
		Sample Code Set 2B: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-Different orders of recursion are used.
		-The red line is the line from before (2), it has order of recursion 1.
		-A more advanced blip line is then drawn in blue above the red blip line.
		-The blue line has nested zigzags/blips from its order of recursion 2.
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture7.png" alt="See the Image" />
		
		See code below:

#Sample Code Set #2B (what you gave us)
# Define the blip_line function
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

initializeTurtle()

# Draw blip lines of different orders
jump(50, 400)
face(90)
color('red')
blip_line(800, 1)  # Order 1

jump(50, 350)
face(90)
color('blue')
blip_line(800, 2)  # Order 2

show()

</p>
</p>
		
		Sample Code Set 2C: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-A green blip line is produced with order of recursion 3. 
		-This has more sets of nested blips than prior orders.
		-As more orders are produced, the pattern gets closer the a Koch Snowflake.
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture8.png" alt="See the Image" />
		
		See code below:
		
#Sample Code Set 2C (what you gave us)
initializeTurtle()
showturtle()

jump(50, 300)
face(90)
color('green')
blip_line(800, 3)  # Order 3

show()

 </p>
 </p>
		
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          In this placeholder section, you might describe observations,
          results, or insights gained from any analysis. You can incorporate 
          references to equations (e.g., $y = mx + b$) or embed images and 
          other visual aids to illustrate your points.
        </p>




        <figure>
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/800px-Mandel_zoom_00_mandelbrot_set.jpg"
            alt="Mandelbrot Broad View"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Figure 1:</strong> A broad view of the Mandelbrot set 
            (max_iter = 100). Colors represent how many iterations were 
            needed to exceed |z|=2.
          </figcaption>
        </figure>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
