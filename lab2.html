<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Courteney Zboyan <br />
      2/1/25
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
	Module 2

		This lab report explores the Random Walk Function, the Koch Snowflake, and the Dragon Curve.
		Sample code is provided and then experimental code is made.
		What the code does will be outlined.
		
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
	
		Sample Code Set #1: Random Walk Function
		-This code imports a custom turtle library to use various turtle functions. 
		-At first, the code did not work because the command was non-standard, so this had to be imported.
		-Random import allows us to use various random functions later on.
		-The canvas is initialized with width of 1000 and height of 800
		-The random walk function is defined.
		-The jump and penup command moves the start to 450x450
		-A loop is used to repeat the functions 1000 times (steps) with distance of 10 pixels (step length).
		-The result is then displayed. I ran the code twice, to verify the random-ness.

		See Images:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture1.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/picture2.png" alt="See the Image" />
		
		See code below:

#Sample Code Set 1 (intact as you gave, besides for one fix and some comments)
import random

# This code installs the turtle library
!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *
#At first, the code did NOT work. Upon analyzing the error, I went back and grabbed this above code from Module 1

# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
#the canvass width is set to 1000 by 800 pixels
#initially, the code did NOT work before the Hahn turtle library was stated as the "initialize turtle" is non-standard

# Step 2: Function to perform a random walk (Brownian motion)
#The random walk function is something I recognize from Statistics class of "Time Series" 
def random_walk(steps, step_length):
    speed(0)             # Set speed to maximum for faster drawing
    penup()               #raises pen to move it
    jump(450, 450)       # Start near the middle of the canvas
    pendown()             #puts pen down to draw

    for _ in range(steps):
        forward(step_length)               # Move forward by the step length
        right(random.uniform(-180, 180))   # Turn by a random angle between -180 and 180 degrees

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10

random_walk(steps, step_length)

# Step 4: Display the result
show()
		
 </p>
 </p>
		
		Experimental Code Set 1A: Altering the Random Walk Code:
		Some adjustments were made to the original code, namely:
		-A black background 
		-Use of a random vibrant color for each step, from a predetermined list of 8 colors

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture3.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1A (black background, varying random vibrant colors)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(450, 450)  # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color
        forward(step_length)  # Move forward by the step length
        right(random.uniform(-180, 180))  # Turn by a random angle

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10
random_walk(steps, step_length)

# Step 4: Display the result with the goal of eye popping design
show()		#This looks like an animal with a tail and short limbs!

 </p>
 </p>
		
		Experimental Code Set 1B: More altering the Random Walk Code:
		Some more adjustments were made to the previous code, namely:
		-a reduced canvas size of 500x400
		-adjusted start to 250x250
		-increased steps to 2000 and decresed step length to 5
		

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture4.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1B (more steps, smaller length)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
#I reduced canvas width

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(250, 250)  # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color
        forward(step_length)  # Move forward by the step length
        right(random.uniform(-180, 180))  # Turn by a random angle

# Step 3: Execute the random walk with 2000 steps and/or step length of 5 now
steps = 2000
step_length = 5
random_walk(steps, step_length)

# Step 4: Display the result with the goal of eye popping design that fit on a smaller canvas
show()
		
 </p>
 </p>
		
		Experimental Code Set 1C: More altering the Random Walk Code:
		Some more adjustments were made to the previous code, namely:
		-a varying step size from a random selection of 4 odd numbers: 3, 5, 7, or 9
		-if/else loop to sometimes reflect the turtle motion, creating a mirrored pattern

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture5.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 1C (varying step size)
import random

# Step 1: Initialize the turtle canvas
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Set background color to black
bgcolor("black")

# Define a list of vibrant colors
vibrant_colors = ["red", "lime", "cyan", "magenta", "yellow", "orange", "blue", "purple"]

# Step 2: Function to perform a random walk with varying step lengths and symmetry
def random_walk(steps, step_lengths):
    speed(0)  # Set speed to maximum for faster drawing
    penup()
    jump(250, 200)  # Start near the center of the canvas
    pendown()

    for _ in range(steps):
        color(random.choice(vibrant_colors))  # Choose a random vibrant color

        # Varying step length
        step_length = random.choice(step_lengths)  # Pick a random step size
        forward(step_length)  # Move forward by the step length

        # Symmetry: Reflect the movement across the vertical axis
        if random.choice([True, False]):
            left(180)  # Turn by 180 degrees (reflecting horizontally)

        right(random.uniform(-180, 180))  # Random turn to maintain randomness

# Step 3: Execute the random walk with varying step lengths and 2000 steps
steps = 2000
step_lengths = [3, 5, 7, 9]  # 4 Different possible step lengths
random_walk(steps, step_lengths)

# Step 4: Display the result with these new features
show()
		
 </p>
 </p>
		
		Sample Code Set 2: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-First, the canvas is initialized
		-The start is set at 50x400 and the turtle faces up (90 degrees).
		-A blip/zig zag bump is then drawn in a horizontal line using a 60 CCW, 120 CW, 60 CCW degree rotation
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture6.png" alt="See the Image" />
		
		See code below:

#Sample Code Set #2 (what you gave us)
initializeTurtle()
showturtle()

jump(50, 400)
face(90)

# Line with blip
forward(800 / 3)
left(60) 
forward(800 / 3)
right(120)
forward(800 / 3)
left(60)
forward(800 / 3)

show()

 </p>
 </p>
		
		Sample Code Set 2B: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-Different orders of recursion are used.
		-The red line is the line from before (2), it has order of recursion 1.
		-A more advanced blip line is then drawn in blue above the red blip line.
		-The blue line has nested zigzags/blips from its order of recursion 2.
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture7.png" alt="See the Image" />
		
		See code below:

#Sample Code Set #2B (what you gave us)
# Define the blip_line function
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

initializeTurtle()

# Draw blip lines of different orders
jump(50, 400)
face(90)
color('red')
blip_line(800, 1)  # Order 1

jump(50, 350)
face(90)
color('blue')
blip_line(800, 2)  # Order 2

show()

</p>
</p>
		
		Sample Code Set 2C: Building the Koch Snowflake piece by piece
		-This code steadily builds the Koch Snowflake, one side or section at a time.
		-A green blip line is produced with order of recursion 3. 
		-This has more sets of nested blips than prior orders.
		-As more orders are produced, the pattern gets closer the a Koch Snowflake.
		-The result is shown

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture8.png" alt="See the Image" />
		
		See code below:
		
#Sample Code Set 2C (what you gave us)
initializeTurtle()
showturtle()

jump(50, 300)
face(90)
color('green')
blip_line(800, 3)  # Order 3

show()

 </p>
 </p>

		Sample Code Set 2D: The Complete Koch Snowflake
		-The complete Koch Snowflake is drawn.
		-The blipline function is used to draw this shape.
		-If the order is 0, a straight line is drawn.
		-Otherwise (else), the line is broken into four segments to create the zigzag.
		-The segments are as follows straight line, 60 CCW, 120 CW, 60 CCW degree rotation.
		-The function is called, or repeated, thrice.
		-The shape is drawn with pixel length 400 and all in blue.
		-The result is shown.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture9.png" alt="See the Image" />
		
		See code below:
		
#Sample Code Set 2D (what you gave us)
initializeTurtle()
showturtle()

# Define the blip_line function (Koch curve)
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

# Draw the Koch snowflake
def koch_snowflake(length, order):
    for _ in range(3):
        blip_line(length, order)
        right(120)

# Set up the turtle
jump(250, 500)
face(0)
color('blue')

# Draw the snowflake
length = 400
order = 3
koch_snowflake(length, order)

show()

 </p>
 </p>

		Experimental Code Set 2: Broken Snowflake
		-I adjusted the background color to black and line color to lime.
		-A small rotation angle of 10 degrees is introduced which adds an extra rotation.
		-This creates asymmetry and pinches the snowflake in on itself.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture11.png" alt="See the Image" />
		
		See code below:
		
#Experimental Code Set 2: I "broke" the snowflake a bit
initializeTurtle()
showturtle()

# Set background color to black
bgcolor("black")

# Define the blip_line function (Koch curve) with rotation
def blip_line(length, order, rotation_angle):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1, rotation_angle)
        left(60)
        blip_line(length / 3, order - 1, rotation_angle)
        right(120)
        blip_line(length / 3, order - 1, rotation_angle)
        left(60)
        blip_line(length / 3, order - 1, rotation_angle)

# Draw the Koch snowflake with rotation
def koch_snowflake(length, order):
    rotation_angle = 10  # Small rotation angle for effect
    for _ in range(3):
        blip_line(length, order, rotation_angle)
        right(120)
        # Apply additional rotation effect after each side
        right(rotation_angle)

# Set up the turtle
jump(250, 500)
face(0)
color('lime')

# Draw the snowflake
length = 400
order = 3
koch_snowflake(length, order)

show()

 </p>
 </p>

		Experimental Code Set 2B: Further Broken
		-The Snowflake became even more distorted with this code.
		-A random rotation angle of 30 degrees CCW to 30 degrees CW was introduced 
		-A random length of each segment of 0.8 to 1.2 was introduced.
		-A random color choice from 5 colors was introduced.
		-A smaller canvas was applied.
		-The snowfalke appears distorted due to varying angles, colors, and lengths.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture12.png" alt="See the Image" />
		
		See code below:
		
#Experimental Code Set 2B: I "broke" the snowflake more + randomized colors and angles
import random

# Define the blip_line function (Koch curve) with random rotation and length variations
def blip_line(length, order, rotation_angle):
    if order == 0:
        forward(length)
    else:
        # Randomize rotation and length to "break" the snowflake
        random_rotation = random.randint(-30, 30)  # Random rotation within -30 to 30 degrees
        random_length = length * random.uniform(0.8, 1.2)  # Randomize length by 80%-120%
        
        # Apply randomization
        color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))
        blip_line(random_length / 3, order - 1, rotation_angle + random_rotation)  # Apply rotation variation
        left(60)
        
        color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))
        blip_line(random_length / 3, order - 1, rotation_angle + random_rotation)
        right(120)
        
        color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))
        blip_line(random_length / 3, order - 1, rotation_angle + random_rotation)
        left(60)
        
        blip_line(random_length / 3, order - 1, rotation_angle + random_rotation)

# Draw the Koch snowflake with randomized rotation and length
def koch_snowflake(length, order):
    rotation_angle = random.randint(5, 15)  # Start with a random rotation angle
    for _ in range(3):
        blip_line(length, order, rotation_angle)
        right(120)
        right(rotation_angle)  # Apply additional random rotation

# Set up the turtle
initializeTurtle()
#shrinking canvas width and height
canvas_width = 500
canvas_height = 500
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
bgcolor("black")
showturtle()

# Set up drawing
jump(100, 300)  # Start position
face(0)

# Define initial color for the first side
color('lime')

# Draw the snowflake
length = 200  # Smaller size for better fit
order = 3  
koch_snowflake(length, order)

show()

 </p>
 </p>

		Experimental Code Set 2C: Stretch Mirror Image
		-This stretched out the fractal and created a mirror image.
		-The length was dropped to 200 and the start placement was adjusted to 100x500
		-Three set colors were chosen and cycled through using a set order for each segment after a turn.
		-A little over half the snowflake pattern is drawn before it restarts.
		-The partial/slightly over half snowflakes are connected.
		-The pattern looks like a set of crowns.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture13.png" alt="See the Image" />
		
		See code below:
		
#Experimental Code Set 2C: I mirrored the fractal with a 3 color pattern
# Define the blip_line function (Koch curve) with mirroring
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        # Color for first segment (cyan)
        color('cyan')
        blip_line(length / 3, order - 1)
        left(60)
        
        # Color for second segment (lime)
        color('lime')
        blip_line(length / 3, order - 1)
        right(120)
        
        # Color for third segment (magenta)
        color('magenta')
        blip_line(length / 3, order - 1)
        left(60)
        
        # Continue with the next segment (color applied already)
        blip_line(length / 3, order - 1)

# Set up the turtle
initializeTurtle()
bgcolor('black')  # Set background color to black
showturtle()

# Set up drawing
jump(100, 500)  # Start position
face(0)

# Draw the snowflake
length = 200
order = 3
koch_snowflake(length, order)

show()
		
 </p>
 </p>

		Sample Code Set 3: Dragon Curve
		-The dragon curve is a famous fractal known for its self similar structure.
		-Each segment breaks twice with alternating turn direction at 90 degrees to create the zigzag pattern.
		-The length scales down by 1/sqrt of 2 to maintain the shape.
		-A purple color is used for visibility, order 10 creates more recursion.
		-The curve is unique in that it never crosses itself even though it is complex and mesmerizing.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture10.png" alt="See the Image" />
		
		See code below:
		
#Sample Code Set 3 (what you gave us)
# Define the dragon curve function
def dragon_curve(order, length, turn_direction):
    # Base case: if order is 0, just move forward
    if order == 0:
        forward(length)
    else:
        # Calculate the new length for each recursive step
        new_length = length / (2 ** 0.5)

        # Recursively draw the dragon curve, turning right and left as needed
        dragon_curve(order - 1, new_length, 1)  # First segment
        right(turn_direction * 90)             # Turn by 90 degrees
        dragon_curve(order - 1, new_length, -1) # Second segment

# Initialize the turtle for drawing
initializeTurtle()

# Move the turtle to a starting position
jump(400, 400)
face(0)             # Set starting direction
color('purple')     # Choose a color

# Draw the dragon curve
order = 10          # Complexity level
length = 300        # Initial length of each segment
dragon_curve(order, length, 1)

# Show the final drawing
show()

</p>
</p>

		Experimental Code Set 3: Smudging the curve
		-The background is black.
		-A randomized turning angle between 60 and 120 degrees in introduced. 
		-The standard dragon curve structure is broken, which causes segments to overlap at times and smudge.
		-1 random color out of a set of 5 colors is chosen for the entire drawing.
		-The order is increased to 15 which increases the recursion and overlap. 
		-The result is a compact smudged shape.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture14.png" alt="See the Image" />
		
		See code below:
		
#Experimental Code Set 3 (makes a "smudge" in a random color chosen from 5)
import random
def dragon_curve(order, length, turn_direction):
    if order == 0:
        forward(length)
    else:
        new_length = length / (2 ** 0.5)
        dragon_curve(order - 1, new_length, 1)
        right(random.randint(60, 120))  # Random turn between 60° and 120°
        #this helps helps cause the smudge
        dragon_curve(order - 1, new_length, -1)

# Initialize the turtle for drawing
initializeTurtle()
#shrunk canvas size
canvas_width = 500
canvas_height = 500
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
bgcolor('black')  # Set background color to black

# Move the turtle to a starting position
jump(200, 200)
face(0)             # Set starting direction
color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))     
# Choose a random color out of 5 options

# Draw the dragon curve
order = 15        # order increased to 15 helps cause the smudge
length = 500        # Initial length of each segment
dragon_curve(order, length, 1)

show()

</p>
</p>

		Experimental Code Set 3B: Massive Smudge
		-The background is black.
		-Multiple layers occur in the smudge.
		-For each layer, the color changes from a set of 5 colors.
		-The first layer has the highest order of 12 and it the most complex.
		-Each layer after gets simplier as lower recursion means more spread out.
		-The start position shifts after each layer.

		See Images:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture15.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/picture15b.png" alt="See the Image" />
		
		See code below:

#Experimental Code Set 3B (makes a massive "smudge" in a random colors chosen from 5)
# Draw multiple layers with each having a change in color
for i in range(5):
    jump(200 + i * 20, 200 + i * 20)
    color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))  # Random color for each layer
    dragon_curve(12 - i, length, 1)

show()

</p>
</p>
		Final Code Set: Drew both Snowflake and Dragon in random colors
		-Presented both fractals in one screen with each a random color from a choice of 5 colors. 
		-Dragon on the left and Snowflake on the right in a black background.
		-The start points are adjusted so they do not overlap.
		-It is neat to see both together to compare and contrast.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/picture16.png" alt="See the Image" />
		
		See code below:

#Displays a Dragon curve and Koch snowflake in random colors on left and right side on screen
import random

# Dragon Curve Function
def dragon_curve(order, length, turn_direction):
    if order == 0:
        forward(length)
    else:
        new_length = length / (2 ** 0.5)
        dragon_curve(order - 1, new_length, 1)
        right(turn_direction * 90)
        dragon_curve(order - 1, new_length, -1)

# Koch Snowflake Function
def koch_snowflake(order, length):
    if order == 0:
        forward(length)
    else:
        length /= 3
        koch_snowflake(order - 1, length)
        left(60)
        koch_snowflake(order - 1, length)
        right(120)
        koch_snowflake(order - 1, length)
        left(60)
        koch_snowflake(order - 1, length)

# Initialize the Turtle and Screen
initializeTurtle()
#shrunk canvas size
canvas_width = 700
canvas_height = 500
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')
bgcolor('black')  # Set background color

# Draw the Dragon Curve on the Left Side
jump(100, 300)  # Move to the left side
face(0)  # Set starting direction
color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))  # Random color
dragon_curve(10, 300, 1)  # Draw dragon curve

# Draw the Koch Snowflake on the Right Side
jump(500, 300)  # Move to the right side
face(0)  # Reset direction
color(random.choice(['cyan', 'lime', 'magenta', 'red', 'yellow']))  # Random color

# Draw all three sides of the Koch Snowflake
for _ in range(3):
    koch_snowflake(4, 200)  # Draw Koch Snowflake
    right(120)  # Turn to draw the next side

# Show Final Drawing
show()

</p>
</p>
		
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          Summary from the TED talk: 
		"He prefers “roughness.” It fits better.
		Talks about a Cauliflower and repeated cutting if it.
		D is a practical measure of roughness. Space-filling area. 
		D = roughness, a parameter that is often calculated off of fractal shapes or shapes that did not exist even in nature. 
		An example is the Peano curve. In a snowflake, drawing “Mandelbrot curves” makes the shape seem more natural. 
		Fractals have applications in Finance such as stock charts. 
		Fractals also help refine bell curves. 
		He concluded the talk about the Mandelbrot Set and it’s simple z = z^2 + c equation. 
		The shape is emphasized with different colors or patterns around it."

        </p>

	Comparing the Snowflake and the Dragon. 
	      The Snowflake starts with an equilaterial triangle while the Dragon starts with a line.
	      The Snowflake is self-similar while the Dragon is self-intersecting.
	      The Snowflake has smooth transitions while the Dragon has intersecting ones.
	      The Snowflake is symmetric while the Dragon is not.
	      The Snowflake does not fill a 2D space like the Dragon does.
	      The Snowflake has a predictable shape while the Dragon does not.


      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          This conclusion emphasizes how the iterative process of fractal generation unveils the complexity hidden within.  
		With even slight parameter adjustments, unique fractal patterns were created.  
		The designs show the theory behind fractals such as the Mandelbrot Set, Koch Snowflake, and Dragon Curve along with the power of coding.
		Thus, fractals have many application across fields.
      </section>

     

     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
