<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
     Courteney Zboyan <br />
     2/14/25
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         This Module 3 features the Sierpinski Triangle and Wolfram Rules. A brief intro is presented before coding examples of both.
		The Sierpinski Triangle is a famous fractal that is self - similar. It can be developed using Rule 90 of the Wolfram Rules or with Geometric recursion.
		Use of Rule 90 relies on having a grid while Geometric recursion is more free-form.
		The Sierpinski Triangle is an equilateral triangle with smaller and smaller copies inside itself based on the order of recursion.
		The Wolfram Rules are cellular automata rules developed by Stephen Wolfram in the 1980's. 
		They are 1D rules where each cell has a state of either alive (1) or dead (0) where the next possible state of the cell is determined by it's immediate neighbors.
		The left, center, and right determine the state. Since there are 3 positions and 2 states, then there are 2^3 = 8 possible combinations.
		A rule number from 0 to 255 (there are 256 rules in total), then determines the next state of the cell. This number is converted into 8-bit binary and sets the neighborhood pattern.
		There are a few different well-known rules such as Rule 30 (chaotic behavior), Rule 90 (Sierpinski Triangle), and Rule 110 (Turing Complete).
		These rules can simulate complex systems simply, model natural occurences like fractals, and create prodecural patterns like those that occur in cryptography.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">



      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>

Install the key file:
-The code lines below install a custom file for python.
		
         !wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *

		//
Sample Code 1: Draw equilateral Triangle
-The code below draws a green equilaterial triangle. 
-The drawing starts at 300x500 and draws each side with 400 length.
-The turtle is facing up to start and 120 degree left turns are made.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic1.png" alt="See the Image" />
		
		See code below:
		
initializeTurtle()
showturtle()

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

# Set up the turtle
jump(300, 500)
face(90)
color('green')
length = 400
draw_triangle(length)

show()

		//
Experimental Code #1A: Draw green triangle and fill with yellow
-The begin_fill and end_fill functions fill in the triangle with default color of yellow

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic2.png" alt="See the Image" />
		
		See code below:

initializeTurtle()
showturtle()

# Define the function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        left(120)
    end_fill()  # End filling

# Set up the turtle
jump(300, 500)
face(90)
color('green')
length = 400

draw_triangle(length)  # Draw and fill the triangle

show()

		//
Experimental Code#1B: Draw lime triangle, thick borders,filled in
-canvas dimensions shrunk
-background color is now black
-altered start to fit
-border width is 20
-side length is 100
-faces down and turns right 120 degrees
-border is lime and fill is yellow

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic3.png" alt="See the Image" />
		
		See code below:

canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()

# Define the function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        right(120)
    end_fill()  # End filling

# Set up the turtle
bgcolor("black")
jump(200, 200)
face(270)
color('lime')
width(20)
length = 100


draw_triangle(length)  # Draw and fill the triangle

show()
		//
Experimental Code#1C: Spiral of Triangles:
-a colorful sprial of triangles is created.
-each has a different border color and fill color from a predetermined set a random colors
-the canvas width is reduced to 500x400 with the drawing centered on 200x200 on black background
-20 triangles are produced with side length 100 and border width 5
-after a triangle is drawn, the turtle is rotated 18 degrees to cause slight displacement

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic4.png" alt="See the Image" />
		
		See code below:

import random

canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()
bgcolor("black")  # Set background color to black
jump(200,200)  # Center the spiral
face(270)  # Start facing downward

# Function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        right(120)
    end_fill()  # End filling

# Create a spiral with random colors
length = 100
num_triangles = 20  # Adjust for more/less triangles
angle_step = 18  # Rotation per step

for i in range(num_triangles):
    # Generate random outline and fill colors
    outline_color = random.choice(['red', 'blue', 'green', 'purple', 'cyan', 'magenta', 'white', 'orange'])
    fill_color = random.choice(['yellow', 'white', 'orange', 'pink', 'lightblue', 'lime'])
    
    color(outline_color)  # Set outline color
    fillcolor(fill_color)  # Set fill color
    width(5)  # Thicker border for visibility
    
    draw_triangle(length)  # Draw the triangle
    right(angle_step)  # Rotate to create the spiral effect

show()
		//
Sample Code 2: draw famous recursive Sierpinski Triangle
-this fractal involves drawing an equilateral triangle and recursively subdividing it
-the function is defined with length of side and order of recursion
-if the order is 0, a single triangle is drawn
-if else, higher order, the triangle is split into 3 smaller triangles
-the drawing is set to be displayed, centered at 300x500, starts upward, and drawn in green
-the side length is 400 with order of recursion 4

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic5.png" alt="See the Image" />
		
		See code below:
		
# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

initializeTurtle()
showturtle()

# Set up the turtle
jump(300, 500)
face(90)
color('green')

# Draw the Sierpinski triangle
length = 400
order = 4
sierpinski_triangle(length, order)

show()
		//
Experimental Code Set 2:
-a black blackground and new center 200x300 are set
-a higher order of recrusion 5 and shorter length of 250 are set
-the main triangle is blue, with the smallest triangles filled with a random color from a predetermined set.

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic6.png" alt="See the Image" />
		
		See code below:
		
import random

# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        fillcolor(random.choice(['red', 'blue', 'green', 'purple', 'cyan', 'magenta', 'white', 'orange', 'yellow']))
        begin_fill()
        draw_triangle(length)
        end_fill()
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

# Initialize turtle settings
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()
bgcolor("black")  # Set background to black
jump(200, 300)  # Adjust position for better centering
face(90)  # Face upwards

# Draw the Sierpinski triangle with randomized colors
length = 250  # Smaller length for better fit
order = 5  # Increased recursion depth
sierpinski_triangle(length, order)

show()
		//
Sample Code Set 3: Cellular Automata
-1D Cellular Automata is created and displayed in a binary pattern
-0 means black and 1 means white
-fractals are produced based on something called Wolfram rules 
-libraries are important to setup to arrays and visualize it
-a grid function is defined
-a 100x100 grid is initialized with everything being black (using 0's)
-the first row's center cell [0,50] is set to white (using a 1)
-Wolfram rule 90 is defined as an 8-bit to print the sierpinski triangle
-Rule 90 is then encoded for different neighborhood states in a 3D array with binary rules
-a function is then defined to apply cellular automata rules
-the function applies the rules based on the 3 cells (Northwest, North, and Northeast) above the current cell
-a redefinement is needed since "rule" is not an array, but binary mask, although it is not apparently used other than that
-the example of rule 90, sierpinski triangle, is displayed.
-more examples of different rules are displayed: 30, 62, 110, and 126

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic7.png" alt="See the Image" />
		
		See code below:

		
import numpy as np
import matplotlib.pyplot as plt

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)

num = 90
print(f'{num:08b}')

rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 1
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 1
rule[1,1,1] = 0

def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X

    plot(CA(C))

def CA(X):

    for i in range(1,X.shape[0]-1): #row
      for j in range(1,X.shape[1]-1): #col

            X[i,j] = (rule/(2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2

    return X

rule = 90

plot(CA(C))

for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
		//
Experimental Code #3: a color change
-a colormap is added with the default being plasma
-like before, the neighboring cells are analyzed to determine if 0 (no color) or 1 (color)
-like before, several rules are run, but this time in color "inferno"

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic8.png" alt="See the Image" />
		
		See code below:

import numpy as np
import matplotlib.pyplot as plt

def plot(x, cmap='plasma'):  # Use a colorful colormap
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap=cmap)  
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

def CA(X, rule):
    """Cellular Automaton using rule-based bitwise operations."""
    rule = np.uint8(rule)  # Convert rule to 8-bit integer
    rows, cols = X.shape
    for i in range(1, rows - 1):  
        neighborhood = (
            4 * X[i - 1, :-2] +  
            2 * X[i - 1, 1:-1] +  
            X[i - 1, 2:]  
        )
        X[i, 1:-1] = (rule >> neighborhood) & 1  # Apply rule using bitwise shift
    return X

# Set up a grid
C = np.zeros((100, 100), dtype=np.uint8)  # Ensure it's uint8 for bitwise ops
C[0, 50] = 1  # Set initial state

# Apply different rules with colors
for rule in [30, 62, 90, 110, 126]:
    plot(CA(C.copy(), rule), cmap='inferno')  # Use a colorful colormap
		//
Experimental Code #3B: Random rules and colors
-a list of 8 colors such as "magma," "turbo," and "coolwarm" are defined.
-five random rules from 256 are generated for which a random color is chosen per each rule.
-before all the drawings, the five randomly selected rules are printed "Randomly selected rules [###, ..., ###]"
-before the drawing, a statement is displayed via print "Rule ### using colormap xxxxxx"

		See Image:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic9.png" alt="See the Image" />
		
		See code below:

import numpy as np
import matplotlib.pyplot as plt
import random

def plot(x, cmap):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap=cmap)  
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

def CA(X, rule):
    rule = np.uint8(rule)  
    rows, cols = X.shape

    for i in range(1, rows - 1):  
        neighborhood = (
            4 * X[i - 1, :-2] +  
            2 * X[i - 1, 1:-1] +  
            X[i - 1, 2:]  
        )
        X[i, 1:-1] = (rule >> neighborhood) & 1  

    return X

# Set up a grid
C = np.zeros((100, 100), dtype=np.uint8)  
C[0, 50] = 1  

# List of colormaps to randomly choose from
colormaps = ['inferno', 'plasma', 'magma', 'viridis', 'cividis', 'coolwarm', 'turbo']

# Generate and apply 5 random rules with random colors
random_rules = np.random.choice(range(256), size=5, replace=False)
print("Randomly selected rules:", random_rules)

for rule in random_rules:
    cmap = random.choice(colormaps)  # Pick a random colormap
    print(f"Rule {rule} using colormap: {cmap}")
    plot(CA(C.copy(), rule), cmap=cmap)  
		//
Experimental Code #3C: Game of Life
-a game board of 50x50 is set where each cell has a probability of 80% dead (0) and 20% alive (1)
-There are two options to determine how the cells change status for each of the 9 steps after the initial step
-a live cell dies if it has less than 2 neighbors or more than 3 neighbors
-a dead cell revives if it has exactly 3 live neighbors
-these are discrete values: "<2 neighbors or >3neighbors" and "=3 neighbors"
-each step has a different color selected from a predetermined list.
-each step prints the "color", the step number "#" and the population of "alive: #### vs dead: ####"
-these values are stored and a summary of the initial alive, end alive, max alive, and min alive is printed at the end

	See Images:
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic10.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic11.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic12.png" alt="See the Image" />
		<img src="https://github.com/Zboyan/labreports/blob/main/m3%20pic13.png" alt="See the Image" />
		
		See code below:
	
import numpy as np
import matplotlib.pyplot as plt
import random

def plot(grid):
    """Displays the grid using a random colormap."""
    colormaps = ['inferno', 'plasma', 'magma', 'viridis', 'cividis', 'coolwarm', 'turbo']
    cmap = random.choice(colormaps)  # Choose a random colormap each step
    fig, ax = plt.subplots()
    im = ax.imshow(grid, cmap=cmap)
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()
    print(f"Using colormap: {cmap}")  # Print which colormap was used

def game_of_life(grid, steps=10):
    """Simulates Conway's Game of Life with random colors per step and logs statistics."""
    rows, cols = grid.shape
    alive_counts = []
    dead_counts = []

    for step in range(steps):
        new_grid = grid.copy()

        for i in range(1, rows - 1):
            for j in range(1, cols - 1):
                # Count live neighbors
                neighbors = np.sum(grid[i-1:i+2, j-1:j+2]) - grid[i, j]

                # Apply rules
                if grid[i, j] == 1 and (neighbors < 2 or neighbors > 3):
                    new_grid[i, j] = 0  # Underpopulation or overpopulation
                elif grid[i, j] == 0 and neighbors == 3:
                    new_grid[i, j] = 1  # Reproduction

        grid = new_grid.copy()
        plot(grid)  # Show updated grid with a random color

        # Count alive and dead cells
        alive = np.sum(grid)
        dead = grid.size - alive
        alive_counts.append(alive)
        dead_counts.append(dead)
        print(f"Step {step + 1}: Alive = {alive}, Dead = {dead}")  

    # Print summary
    print("\nSummary of the simulation:")
    print(f"Initial alive cells: {alive_counts[0]}")
    print(f"Final alive cells: {alive_counts[-1]}")
    print(f"Maximum alive cells: {max(alive_counts)} at step {alive_counts.index(max(alive_counts)) + 1}")
    print(f"Minimum alive cells: {min(alive_counts)} at step {alive_counts.index(min(alive_counts)) + 1}")

# Initialize a random grid
size = 50  # Grid size
initial_grid = np.random.choice([0, 1], size=(size, size), p=[0.8, 0.2])

# Run Game of Life for 10 steps
game_of_life(initial_grid, steps=10)
		//

		
        </p>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
         This Module explored both the Sierpinski Triangle and Wolfram Rules. 
		The Sierpinski Triangle was generated both recursively and using Wolfram Rule 90. 
		Other Wolfram Rules and applications were also explored. 
		This module showed the powerful effects of recursion and Wolfram Rules.
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
