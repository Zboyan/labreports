<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
     Courteney Zboyan <br />
     2/14/25
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is a sample introduction showcasing how you might structure 
          your opening section. Replace this paragraph with a concise 
          overview of the topic or project you are addressing. You can then 
          expand the explanation as needed.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">



      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>

Install the key file:
-The code lines below install a custom file for python.
		
         !wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *

		//
Sample Code 1: Draw equilateral Triangle
-The code below draws a green equilaterial triangle. 
-The drawing starts at 300x500 and draws each side with 400 length.
-The turtle is facing up to start and 120 degree left turns are made.
		
initializeTurtle()
showturtle()

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

# Set up the turtle
jump(300, 500)
face(90)
color('green')
length = 400
draw_triangle(length)

show()

		//
Experimental Code #1A: Draw green triangle and fill with yellow
-The begin_fill and end_fill functions fill in the triangle with default color of yellow

initializeTurtle()
showturtle()

# Define the function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        left(120)
    end_fill()  # End filling

# Set up the turtle
jump(300, 500)
face(90)
color('green')
length = 400

draw_triangle(length)  # Draw and fill the triangle

show()

		//
Experimental Code#1B: Draw lime triangle, thick borders,filled in
-canvas dimensions shrunk
-background color is now black
-altered start to fit
-border width is 20
-side length is 100
-faces down and turns right 120 degrees
-border is lime and fill is yellow

canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()

# Define the function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        right(120)
    end_fill()  # End filling

# Set up the turtle
bgcolor("black")
jump(200, 200)
face(270)
color('lime')
width(20)
length = 100


draw_triangle(length)  # Draw and fill the triangle

show()
		//
Experimental Code#1C: Spiral of Triangles:
-a colorful sprial of triangles is created.
-each has a different border color and fill color from a predetermined set a random colors
-the canvas width is reduced to 500x400 with the drawing centered on 200x200 on black background
-20 triangles are produced with side length 100 and border width 5
-after a triangle is drawn, the turtle is rotated 18 degrees to cause slight displacement

import random

canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()
bgcolor("black")  # Set background color to black
jump(200,200)  # Center the spiral
face(270)  # Start facing downward

# Function to draw and fill an equilateral triangle
def draw_triangle(length):
    begin_fill()  # Start filling
    for _ in range(3):
        forward(length)
        right(120)
    end_fill()  # End filling

# Create a spiral with random colors
length = 100
num_triangles = 20  # Adjust for more/less triangles
angle_step = 18  # Rotation per step

for i in range(num_triangles):
    # Generate random outline and fill colors
    outline_color = random.choice(['red', 'blue', 'green', 'purple', 'cyan', 'magenta', 'white', 'orange'])
    fill_color = random.choice(['yellow', 'white', 'orange', 'pink', 'lightblue', 'lime'])
    
    color(outline_color)  # Set outline color
    fillcolor(fill_color)  # Set fill color
    width(5)  # Thicker border for visibility
    
    draw_triangle(length)  # Draw the triangle
    right(angle_step)  # Rotate to create the spiral effect

show()
		//
Sample Code 2: draw famous recursive Sierpinski Triangle
-this fractal involves drawing an equilateral triangle and recursively subdividing it
-the function is defined with length of side and order of recursion
-if the order is 0, a single triangle is drawn
-if else, higher order, the triangle is split into 3 smaller triangles
-the drawing is set to be displayed, centered at 300x500, starts upward, and drawn in green
-the side length is 400 with order of recursion 4
		
# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

initializeTurtle()
showturtle()

# Set up the turtle
jump(300, 500)
face(90)
color('green')

# Draw the Sierpinski triangle
length = 400
order = 4
sierpinski_triangle(length, order)

show()
		//
Experimental Code Set 2:
-a black blackground and new center 200x300 are set
-a higher order of recrusion 5 and shorter length of 250 are set
-the main triangle is blue, with the smallest triangles filled with a random color from a predetermined set.
		
import random

# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        fillcolor(random.choice(['red', 'blue', 'green', 'purple', 'cyan', 'magenta', 'white', 'orange', 'yellow']))
        begin_fill()
        draw_triangle(length)
        end_fill()
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

# Initialize turtle settings
canvas_width = 500
canvas_height = 400
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

showturtle()
bgcolor("black")  # Set background to black
jump(200, 300)  # Adjust position for better centering
face(90)  # Face upwards

# Draw the Sierpinski triangle with randomized colors
length = 250  # Smaller length for better fit
order = 5  # Increased recursion depth
sierpinski_triangle(length, order)

show()
		//
Sample Code Set 3: Cellular Automata
-1D Cellular Automata is created and displayed in a binary pattern
-0 means black and 1 means white
-fractals are produced based on something called Wolfram rules 
-libraries are important to setup to arrays and visualize it
-a grid function is defined
-a 100x100 grid is initialized with everything being black (using 0's)
-the first row's center cell [0,50] is set to white (using a 1)
-Wolfram rule 90 is defined as an 8-bit to print the sierpinski triangle
-Rule 90 is then encoded for different neighborhood states in a 3D array with binary rules
-a function is then defined to apply cellular automata rules
-the function applies the rules based on the 3 cells (Northwest, North, and Northeast) above the current cell
-a redefinement is needed since "rule" is not an array, but binary mask, although it is not apparently used other than that
-the example of rule 90, sierpinski triangle, is displayed.
-more examples of different rules are displayed: 30, 62, 110, and 126

		
import numpy as np
import matplotlib.pyplot as plt

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)

num = 90
print(f'{num:08b}')

rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 1
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 1
rule[1,1,1] = 0

def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X

    plot(CA(C))

def CA(X):

    for i in range(1,X.shape[0]-1): #row
      for j in range(1,X.shape[1]-1): #col

            X[i,j] = (rule/(2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2

    return X

rule = 90

plot(CA(C))

for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
		//
Experimental Code #3: a color change
-
-
-

import numpy as np
import matplotlib.pyplot as plt

def plot(x, cmap='plasma'):  # Use a colorful colormap
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap=cmap)  
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

def CA(X, rule):
    """Cellular Automaton using rule-based bitwise operations."""
    rule = np.uint8(rule)  # Convert rule to 8-bit integer
    rows, cols = X.shape
    for i in range(1, rows - 1):  
        neighborhood = (
            4 * X[i - 1, :-2] +  
            2 * X[i - 1, 1:-1] +  
            X[i - 1, 2:]  
        )
        X[i, 1:-1] = (rule >> neighborhood) & 1  # Apply rule using bitwise shift
    return X

# Set up a grid
C = np.zeros((100, 100), dtype=np.uint8)  # Ensure it's uint8 for bitwise ops
C[0, 50] = 1  # Set initial state

# Apply different rules with colors
for rule in [30, 62, 90, 110, 126]:
    plot(CA(C.copy(), rule), cmap='inferno')  # Use a colorful colormap
		//
Experimental Code #3B: Game of Life
-
-
-



		
        </p>




        <figure>
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/800px-Mandel_zoom_00_mandelbrot_set.jpg"
            alt="Mandelbrot Broad View"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Figure 1:</strong> A broad view of the Mandelbrot set 
            (max_iter = 100). Colors represent how many iterations were 
            needed to exceed |z|=2.
          </figcaption>
        </figure>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
