<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>

<body id="top">



  <header>
    <h1>Fractal Geometry <br> Lab Report : Final Module</h1>
    <p class="author">
      [Courteney Zboyan] <br />
      [4/24/25]
  </header>
</body>


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
	<h2>Intro</h2>
        <p>
          The Final Module features: 
		using point-by-point fractal plotting as the Chaos Game for Siepinski Triangle, 
		using point-by-point fractal plotting for Koch Snowflake, 
		the Barnsley Fern, 
		the use of an L-System to plot a tree via Turtle graphics, 
		the use of MatPlotLib to plot a tree, 
		and Hilbert Curves via Turtle graphics. 
		
		
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->

Sample Code Set #1: Siepinski Triangle
	-This code generates a Siepinski Triangle using the Chaos Game Method.
	-Matplotlib is used to plot the points and numpy is for mathematical operations.
	-Random and randint generate initial points and vertex randomly.
	-A function is defined to calculate a midpoint between two established points of P and Q.
	-The vertices of a triangle are defined as (0,0), (4,0), and (2, 2*np.sqrt(3)) to make it equilateral.
	-The process is initialized with 50000 iterations to make that many points.
	-Each coordinate will have its points stored.
	-The starting point is set to a random location in the plot area.
	-One of the three vertices is chosen, then the midpoint between that and the previous point is found. 
	-The new point becomes the midpoint and the process repeats 50000 times.
	-The points are then plotted in an 8x8 area for the figure.
	-They are set to size 0.1 and blue for visibility.

<section id="code">
<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'b', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic1.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="500"
            loading="lazy"
          />
</figure>

Experimental Code Set #1: Random Colors
	-The same triangle is now generated with random colors by the same method.
	-A list called colors is created with 50000 elements initialized as 0 in order to store colors.
	-Later on, colors[0] followed by three randoms creates a tuple with three random values in RGB format.
	-The decimal is a floatbetween 0 and 1 sets the intensity of Red, Green, and Blue components.
	-Each point gets its own random color and that color is stored in colors[i] in the loop.
	-The colors are plotted easily with the scatter function having color=colors as a list.


<pre><code>

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
colors = [0]*iterates

x[0], y[0] = random(), random()
colors[0] = (random(), random(), random())  # RGB random color

for i in range(1, iterates):
    k = randint(0, 2)
    x[i], y[i] = midpoint(vertices[k], (x[i-1], y[i-1]))
    colors[i] = (random(), random(), random())  # New random color for each point

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=0.1)
plt.title('Sierpinski Triangle with Random Colors')
plt.axis('equal')
plt.show()

	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic2.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="500"
            loading="lazy"
          />
</figure>

Experimental Code Set #2: Koch Snowflake
	-A Koch Snowflake with random colors is now created by this point-by-point plotting method.
	-The build began with an equilateral triangle, then it divided into 3 equal parts, an equilateral bump was placed on the middle third, then it was removed.
	-The process is then repeated for a certain number of iterations.
	-The Koch function specifically features two points and recursion levels.
	-There is a stopping condition, so once the recursion is 0 a straight line between points is returned.
	-The else case uses the two points p1 and p2 converted into arrays to allow for easy math operation.
	-Points that are 1/3 and 2/3's along the line are then found in order to form the bump.
	-The peak point is found by rotating the vector between 1/3 and 2/3's by 60 degrees.
	-Recursion divide splits the line into 4 new sections: p1->1/3, 1/3->peak, peak->2/3, and 2/3->p2 and Koch_curve is called for each.
	-Doubles or duplicates are prevented by subtracting 1.
	-The initial triangle has (0,0), (1,0), and (.5, np.sqrt(3)/2) to make an equilateral triangle.
	-The sides are then formed between each set and double counting is prevented.
	-A giant list is used to collect all points.
	-x and y coordinates are extracted into two lists for plotting.
	-Random colors are generated and points are plotted.

<pre><code>

import matplotlib.pyplot as plt
from random import random
import numpy as np

def koch_curve(p1, p2, level):
    if level == 0:
        return [p1, p2]
    else:
        p1 = np.array(p1)
        p2 = np.array(p2)
        # Points dividing into thirds
        one_third = p1 + (p2 - p1) / 3
        two_third = p1 + 2*(p2 - p1) / 3
        
        # Peak point
        angle = np.pi / 3  # 60 degrees
        direction = two_third - one_third
        peak = one_third + np.array([
            np.cos(angle) * direction[0] - np.sin(angle) * direction[1],
            np.sin(angle) * direction[0] + np.cos(angle) * direction[1]
        ])
        
        # Recursively subdivide
        return (koch_curve(p1, one_third, level-1)[:-1] +
                koch_curve(one_third, peak, level-1)[:-1] +
                koch_curve(peak, two_third, level-1)[:-1] +
                koch_curve(two_third, p2, level-1))

# Initial equilateral triangle points
p1 = (0, 0)
p2 = (1, 0)
p3 = (0.5, np.sqrt(3)/2)

level = 4  # How many iterations (more = finer snowflake)

# Build the sides
side1 = koch_curve(p1, p2, level)[:-1]
side2 = koch_curve(p2, p3, level)[:-1]
side3 = koch_curve(p3, p1, level)

# Gather all points
points = side1 + side2 + side3

# Extract x and y
x = [pt[0] for pt in points]
y = [pt[1] for pt in points]

# Create random colors per point
colors = [(random(), random(), random()) for _ in range(len(points))]

# Plotting
plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=1)
plt.title('Koch Snowflake with Random Colors')
plt.axis('equal')
plt.axis('off')
plt.show()
	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic3.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Sample Code Set #2: Barnsley Fern
	-The Barnsley Fern is generated by iteration with Affine transformations and probabilities.
	-The method is specifically called IFS - Iterated Function System.
	-The random and matplotlib libraries are used to randomly select which transformation to apply and plot points.
	-There are 4 transformation functions of f1, f2, f3, and f4 of the affine variety.
	-These functions each take mathematical operations that modify points in the 2D plane and return the new coordinates.
	-The first function is a vertical shrink which scales the y values by .16, especially pushing the points straight down and mostly contributes to the fern shape at the bottom.
	-The second function scales and rotates the points with .85 and adds a 1.6 vertical offset to generate the dense fronds of the fern.
	-The third function acts like the second, but uses different scaling coefficients to create the smaller branches that extend diagonally.
	-The fourth function is like the previous two, but with different scaling coefficients and less vertical offset, it creates a slight slant to some fronds.
	-The probabilities for each function are displayed as .01, .85, .07, .07 for f1, f2, f3, and f4 respectively; as any valid probability model, they sum to 1.
	-The Barnsley Fern function is now defined with intial condition (0,0) and 100000 iterations.
	-The affine function used is based on a proability from random choice number between 0 and 1.
	-The points are then appended to the points list.
	-The zip(*fern_points) splits the coordinate into two lists of x and y each.
	-The scatter function plots the points in green with size 0.1 on a 6x10 grid space.
	

<pre><code>

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='green')
plt.title('Barnsley Fern')
plt.show()
	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic4.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set#3: Random Colors
	-The same fern is now generated with random colors by the same method.
	-A list called colors is created with 100000 elements initialized as 0 in order to store colors.
	-Later on, colors[0] followed by three randoms creates a tuple with three random values in RGB format.
	-The decimal is a floatbetween 0 and 1 sets the intensity of Red, Green, and Blue components.
	-Each point gets its own random color and that color is stored in colors[i] in the loop.
	-The colors are plotted easily with the scatter function having color=fern_colors as a list.

	<pre><code>

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function with colors
def barnsley_fern_colored(iterations):
    x, y = 0, 0
    points = []
    colors = []

    for _ in range(iterations):
        rand = random.random()
        if rand < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

        # Generate a random RGB color for each point
        colors.append((random.random(), random.random(), random.random()))

    return points, colors

# Generate points and colors
iterations = 100000
fern_points, fern_colors = barnsley_fern_colored(iterations)

# Extract x and y values
x_vals, y_vals = zip(*fern_points)

# Plotting
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color=fern_colors)
plt.title('Colorful Barnsley Fern')
plt.axis('off')  # Optional: turn off the axis for a cleaner look
plt.show()

	</code></pre>

	 <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic5.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set #4: Flowing Colors
	-Now, the fern is created to make the colors flow gradually. 
	-The function linspace(0,1, iterations) generates a smooth set of integers.
	-The plasma colormap is used in converting numbers from 0 to 1 into colors from purple to yellow.

	<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function with color gradient
def barnsley_fern_gradient(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points
iterations = 100000
fern_points = barnsley_fern_gradient(iterations)

# Extract x and y values
x_vals, y_vals = zip(*fern_points)

# Create a color gradient based on iteration index
colors = plt.cm.plasma(np.linspace(0, 1, iterations))

# Plotting
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color=colors)
plt.title('Rainbow Barnsley Fern')
plt.axis('off')  # Hide the axis
plt.show()

	</code></pre>

	<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic6.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set #5: Loop the Rainbow
	-Now, cycles are used to loop the rainbow a set number of times across the fern.
	-The plt.cm.hsv(np.linspace(0, 1, iterations)) is a nice color scheme.
	-The np.roll(colors, cycles, axis=0) shifts the colors across fern points so the rainbow seems to repeat.

	<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function with color cycling
def barnsley_fern_cycling(iterations, cycles=5):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Settings
iterations = 100000
cycles = 8  # Number of color cycles through the fern

# Generate points
fern_points = barnsley_fern_cycling(iterations, cycles)

# Extract x and y values
x_vals, y_vals = zip(*fern_points)

# Create color cycles
colors = plt.cm.hsv(np.linspace(0, 1, iterations * cycles % iterations))

# Repeat the color cycle pattern
colors = plt.cm.hsv(np.linspace(0, 1, iterations))
colors = np.roll(colors, cycles, axis=0)

# Plotting
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color=colors)
plt.title('Rainbow-Cycling Barnsley Fern')
plt.axis('off')
plt.show()

		
	</code></pre>

	<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic7.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set #6: Playing with Probabilites
	-I adjusted the probabilites for each function in the original green fern set previously to be: [0.01, 0.65, 0.17, 0.17]
	-Increasing the f3 and f4 made the fern more bushy and the middle less dense.
	-Then, I adjusted to: [0.01, 0.95, 0.02, 0.02]
	-This makes the fern very skinny.
	-Then, I adjusted to: [0.20, 0.50, 0.15, 0.15]
	-This made a thick stem.
	-Finally, I displayed all 4 in a 2x2 for easy comparison.

<pre><code>

# Settings for different ferns
iterations = 50000  # fewer points to plot faster
settings = [
    ([0.01, 0.85, 0.07, 0.07], "Classic"),
    ([0.01, 0.65, 0.17, 0.17], "Bushy"),
    ([0.01, 0.95, 0.02, 0.02], "Skinny"),
    ([0.10, 0.60, 0.15, 0.15], "Thick Stem"),
]

# Plotting
fig, axs = plt.subplots(2, 2, figsize=(10, 15))

for ax, (probs, title) in zip(axs.flatten(), settings):
    fern_points = barnsley_fern(iterations, probs)
    x_vals, y_vals = zip(*fern_points)
    ax.scatter(x_vals, y_vals, s=0.1, color='green')
    ax.set_title(f"Fern: {title}\n{probs}")
    ax.axis('off')
	
</code></pre>

	<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic8.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Sample Code Set #3:
	-This code draws a fractal tree using L-Systems (Lindenmayer systems) and turtle graphics.
	-The custom library is imported to be able to use other functions and the turtle is initialized/shown.
	-The L-System uses rules inside of characters, if there is no rule then the character is just returned.
	-An axiom is the starting seed 'F' is used here, rules are how to replace characters, and iterations is how many times rules are applied.
	-A very long string that builds the tree structure is built up by repeatedly replacing characters.
	-Each character in the final string is interpreted as a turtle command:
	- "F" move forward and draw a line.
	- "+" turn left by the given angle.
	- "-" turn right by the given angle.
	- "[" is push the current position into a stack in order to save it.
	- "]" is pop (restore) the last saved position.
	- The push and pop make the branching happen.
	- "F" is replaced by a complex string with 4 rounds of re-writing (iterations).
	- The final string is stored in turtle_string and details the entire tree.
	- The start of the string is set to 400x500, oriented right, and set to green color.
	- Each line is 8 units long with turn of 25 degrees.
	
	<pre><code>

# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    stack = []
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        elif command == '[':
            position = (getx(), gety())
            heading_angle = heading()
            stack.append((position, heading_angle))
        elif command == ']':
            position, heading_angle = stack.pop()
            jump(position[0], position[1])
            face(heading_angle)

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}

axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(400, 500)
face(0)
color('green')

# Draw the L-system fractal tree
length = 8
angle = 25
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()

		
	</code></pre>

	 <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic9.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="1200"
            height="600"
            loading="lazy"
          />
        </figure>
	


Experimental Code Set #7:
	-The code was converted from Turtle to MatplotLib in order to do random colors, angles, and branch length easier.
	-Turtle's drawing commands became MatplotLib's ax.plot's.
	-For each branch, a new endpoint was found.
	-Branch lengths were randomized between 0.8 and 1.2 while angles were randomized between 20 and 50 degrees.
	-The axes were hidden and the aspect ratio was maintained to ensure a clean picture.
	-The tree is drawn as line segments, which works better in google colab.

	<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to plot the L-system fractal tree
def draw_lsystem(turtle_string, x, y, angle, length, ax):
    stack = []
    for command in turtle_string:
        if command == 'F':
            # Randomize the length slightly (around base length)
            random_length = length * random.uniform(0.8, 1.2)
            new_x = x + random_length * np.cos(np.radians(angle))
            new_y = y + random_length * np.sin(np.radians(angle))

            # Randomize color
            random_color = (random.random(), random.random(), random.random())
            ax.plot([x, new_x], [y, new_y], color=random_color, lw=0.7)  # Draw line
            x, y = new_x, new_y

        elif command == '+':
            angle += random.randint(20, 50)  # Random left angle
        elif command == '-':
            angle -= random.randint(20, 50)  # Random right angle
        elif command == '[':
            stack.append((x, y, angle))  # Save position and angle
        elif command == ']':
            x, y, angle = stack.pop()  # Restore position and angle

    return x, y  # Return the final position and angle

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}
axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')
ax.axis('off')  # Hide axes

# Starting point and angle
start_x, start_y = 0, 0
start_angle = 90  # Angle pointing upwards
base_length = 8  # Base branch length

# Draw the fractal tree
draw_lsystem(turtle_string, start_x, start_y, start_angle, base_length, ax)

# Display the fractal tree
plt.show()

		
	</code></pre>

	 <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic10.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="600"
            loading="lazy"
          />
        </figure>

Experimental Code Set#8:
	-The random color use was reomved and set to be a consistent color in green.
	-The tree has exactly two birds randomly placed on it with their coordinates listed.
	-The first bird is a red dot and the second is a blue dot with size of s = 50 for visibility.

<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to plot the L-system fractal tree and place two birds randomly
def draw_lsystem(turtle_string, x, y, angle, length, ax):
    stack = []
    bird_positions = []  # List to hold bird positions
    bird_placed = 0  # Counter for birds

    for command in turtle_string:
        if command == 'F':
            # Randomize the length slightly (around base length)
            random_length = length * random.uniform(0.8, 1.2)
            new_x = x + random_length * np.cos(np.radians(angle))
            new_y = y + random_length * np.sin(np.radians(angle))

            # Consistent color for all branches
            branch_color = 'green'
            ax.plot([x, new_x], [y, new_y], color=branch_color, lw=0.7)  # Draw the branch
            x, y = new_x, new_y

            # Place two birds randomly on the tree branches
            if bird_placed < 2 and random.random() < 0.05:  # 5% chance to place a bird
                bird_x = x + random.uniform(0.3, 0.7) * random_length * np.cos(np.radians(angle))
                bird_y = y + random.uniform(0.3, 0.7) * random_length * np.sin(np.radians(angle))
                bird_positions.append((bird_x, bird_y))  # Add bird position to list
                bird_color = 'red' if bird_placed == 0 else 'blue'  # First bird red, second blue
                ax.scatter(bird_x, bird_y, color=bird_color, s=50)  # Plot bird (as a red or blue dot)
                bird_placed += 1  # Increment bird counter

        elif command == '+':
            angle += random.randint(20, 50)  # Random left angle
        elif command == '-':
            angle -= random.randint(20, 50)  # Random right angle
        elif command == '[':
            stack.append((x, y, angle))  # Save position and angle
        elif command == ']':
            x, y, angle = stack.pop()  # Restore position and angle

    return x, y, bird_positions  # Return the final position and bird positions

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}
axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')
ax.axis('off')  # Hide axes

# Starting point and angle
start_x, start_y = 0, 0
start_angle = 90  # Angle pointing upwards
base_length = 8  # Base branch length

# Draw the fractal tree and place birds
final_x, final_y, bird_positions = draw_lsystem(turtle_string, start_x, start_y, start_angle, base_length, ax)

# Display the fractal tree
plt.show()

# Print bird positions
print("Bird positions:")
for i, pos in enumerate(bird_positions, 1):
    print(f"Bird {i}: Position = {pos}")

	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic11.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="600"
            loading="lazy"
          />
        </figure>


Experimental Code Set #9:
	-The cap on birds was removed, such that many more birds are placed on the tree.
	-All birds were set to red. 
	-With the tree green and the birds red, this gives off a Holiday wreath look.

<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to plot the L-system fractal tree and place birds
def draw_lsystem(turtle_string, x, y, angle, length, ax):
    stack = []
    bird_positions = []  # List to hold bird positions

    for command in turtle_string:
        if command == 'F':
            # Randomize the length slightly (around base length)
            random_length = length * random.uniform(0.8, 1.2)
            new_x = x + random_length * np.cos(np.radians(angle))
            new_y = y + random_length * np.sin(np.radians(angle))

            # Fixed color for all branches
            branch_color = 'green'
            ax.plot([x, new_x], [y, new_y], color=branch_color, lw=0.7)  # Draw the branch
            x, y = new_x, new_y

            # Randomly place a bird on the branch (at some position between 30% and 80% of branch length)
            if random.random() < 0.01:  # 1% chance to place a bird on this branch
                bird_x = x + random.uniform(0.3, 0.8) * random_length * np.cos(np.radians(angle))
                bird_y = y + random.uniform(0.3, 0.8) * random_length * np.sin(np.radians(angle))
                bird_positions.append((bird_x, bird_y))  # Add bird position to list
                ax.scatter(bird_x, bird_y, color='red', s=50)  # Plot bird (as a red dot)

        elif command == '+':
            angle += random.randint(20, 50)  # Random left angle
        elif command == '-':
            angle -= random.randint(20, 50)  # Random right angle
        elif command == '[':
            stack.append((x, y, angle))  # Save position and angle
        elif command == ']':
            x, y, angle = stack.pop()  # Restore position and angle

    return x, y, bird_positions  # Return the final position and bird positions

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}
axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')
ax.axis('off')  # Hide axes

# Starting point and angle
start_x, start_y = 0, 0
start_angle = 90  # Angle pointing upwards
base_length = 8  # Base branch length

# Draw the fractal tree and place birds
final_x, final_y, bird_positions = draw_lsystem(turtle_string, start_x, start_y, start_angle, base_length, ax)

# Display the fractal tree
plt.show()

# Print bird positions
print("Bird positions:")
for i, pos in enumerate(bird_positions, 1):
    print(f"Bird {i}: Position = {pos}")

	
</code></pre>

  <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic12.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="600"
            loading="lazy"
          />
        </figure>

Sample Code Set #4: Hilbert Curve
	-Hilbert Curve is drawn by L-System (Lindenmayer systems) and turtle graphics.
	-The custom library is imported to be able to use other functions and the turtle is initialized/shown.
	-The L-System uses rules inside of characters, if there is no rule then the character is just returned.
	-An axiom is the starting seed "L" in this case, rules are how to replace characters, and iterations is how many times rules are applied.
	-A very long string that builds the curve structure is built up by repeatedly replacing characters.
	-Each character in the final string is interpreted as a turtle command:
	- "F" move forward by length.
	- "+" turn left by the specified angle.
	- "-" turn right by the specified angle.
	- Other characters are ignored/passed and treated as placeholders.
	- "L" and "R" have they own strings in the Hilbert function as '-RF+LFL+FR-' and '+LF-RFR-FL+' respectively.
	- 5 iterations and angle of 90 degrees are set.
	- The total size is 400, n is the number of steps (exponentially with powers of 2), and length is size divide n to ensure fit.
	- The start position is 400x500 and orientation is right with color blue.

<pre><code>

# Import necessary modules
import math

# Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rules(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        # 'L' and 'R' are placeholders; we ignore them in drawing
        else:
            pass  # Ignore other characters

# Set the parameters for the Hilbert Curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 5  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 400  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Move to starting position
jump(400, 500)  # Adjust the starting position to fit your canvas
face(0)
color('blue')

# Draw the Hilbert curve
draw_lsystem(hilbert_string, length, angle)

# Display the drawing
show()

	
</code></pre>

	<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic13.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="600"
            loading="lazy"
          />
        </figure>


Experimental Code Set#10:
	-The code was converted from Turtle to MatplotLib in order to do random colors per segments easier.
	-Turtle's drawing commands became MatplotLib's ax.plot's.

<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Function to apply L-system rules
def apply_rules(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Function to plot the L-system fractal using Matplotlib
def draw_lsystem(turtle_string, x, y, angle, length, ax):
    # Initialize the list to store all the segment lines
    lines = []
    
    for command in turtle_string:
        if command == 'F':
            # Calculate the new x and y position
            new_x = x + length * np.cos(np.radians(angle))
            new_y = y + length * np.sin(np.radians(angle))
            
            # Random color for each segment
            random_color = (random.random(), random.random(), random.random())  # RGB values
            
            # Draw the line segment from (x, y) to (new_x, new_y)
            lines.append(((x, y), (new_x, new_y), random_color))
            
            # Update the current position
            x, y = new_x, new_y

        elif command == '+':
            angle += 90  # Turn left by 90 degrees
        elif command == '-':
            angle -= 90  # Turn right by 90 degrees
        else:
            pass  # Ignore other characters (L and R) in drawing

    # Plot the lines on the canvas
    for line in lines:
        (x1, y1), (x2, y2), color = line
        ax.plot([x1, x2], [y1, y2], color=color, lw=0.7)
        
    return x, y

# Define the L-system rules for the Hilbert curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 5  # Adjust the iterations to change the order
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 400  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Set up the Matplotlib figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')
ax.axis('off')  # Hide axes

# Move to starting position (bottom center of the plot)
start_x, start_y = 0, 0

# Draw the Hilbert curve using Matplotlib
final_x, final_y = draw_lsystem(hilbert_string, start_x, start_y, 0, length, ax)

# Display the drawing
plt.show()

	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic14.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="800"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set #11:
	-Segment lengths were randomized between 0.8 and 1.2 while angles were randomized between 70 and 110 degrees.
	-This set has lines cross over each due to the non-right angle potential.
	
<pre><code>

import random
import matplotlib.pyplot as plt
import numpy as np

# Function to apply L-system rules
def apply_rules(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Function to plot the L-system fractal using Matplotlib with randomization for length and angle
def draw_lsystem(turtle_string, x, y, angle, length, ax):
    # Initialize the list to store all the segment lines
    lines = []
    
    for command in turtle_string:
        if command == 'F':
            # Randomize the length slightly (around base length)
            random_length = length * random.uniform(0.8, 1.2)
            
            # Calculate the new x and y position
            new_x = x + random_length * np.cos(np.radians(angle))
            new_y = y + random_length * np.sin(np.radians(angle))
            
            # Random color for each segment
            random_color = (random.random(), random.random(), random.random())  # RGB values
            
            # Draw the line segment from (x, y) to (new_x, new_y)
            lines.append(((x, y), (new_x, new_y), random_color))
            
            # Update the current position
            x, y = new_x, new_y

        elif command == '+':
            # Randomize the left turn angle between 70 and 110 degrees
            angle += random.randint(70, 110)
        elif command == '-':
            # Randomize the right turn angle between 70 and 110 degrees
            angle -= random.randint(70, 110)
        else:
            pass  # Ignore other characters (L and R) in drawing

    # Plot the lines on the canvas
    for line in lines:
        (x1, y1), (x2, y2), color = line
        ax.plot([x1, x2], [y1, y2], color=color, lw=0.7)
        
    return x, y

# Define the L-system rules for the Hilbert curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 5  # Adjust the iterations to change the order
angle = 90

# Generate the L-system string for the Hilbert curve
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step size based on desired size and iterations
size = 400  # Total size of the Hilbert curve (adjust as needed)
n = 2 ** iterations - 1
length = size / n

# Set up the Matplotlib figure
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_aspect('equal')
ax.axis('off')  # Hide axes

# Move to starting position (bottom center of the plot)
start_x, start_y = 0, 0

# Draw the Hilbert curve using Matplotlib
final_x, final_y = draw_lsystem(hilbert_string, start_x, start_y, 0, length, ax)

# Display the drawing
plt.show()


</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic14.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>
	
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          ANALYSIS ANALYSIS ANALYSIS
        </p>




        <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic1.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>


</section>

    
	    



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
     	<h2>Conclusion</h2>
        <p>
        OVERALL CONCLUSION HERE
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
