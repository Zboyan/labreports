<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>

<body id="top">



  <header>
    <h1>Fractal Geometry <br> Lab Report</h1>
    <p class="author">
      [Courteney Zboyan] <br />
      [4/24/25]
  </header>
</body>


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Part 1: TOPIC</h2>
        <p>
          INTRODUCTION INTRODUCTION

		

		
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	
Sample Code Set #1: 
	-This code generates a Siepinski Triangle using the Chaos Game Method.
	-Matplotlib is used to plot the points and numpy is for mathematical operations.
	-Random and randint generate initial points and vertex randomly.
	-A function is defined to calculate a midpoint between two established points of P and Q.
	-The vertices of a triangle are defined as (0,0), (4,0), and (2, 2*np.sqrt(3)) to make it equilateral.
	-The process is initialized with 50000 iterations to make that many points.
	-Each coordinate will have its points stored.
	-The starting point is set to a random location in the plot area.
	-One of the three vertices is chosen, then the midpoint between that and the previous point is found. 
	-The new point becomes the midpoint and the process repeats 50000 times.
	-The points are then plotted in an 8x8 area for the figure.
	-They are set to size 0.1 and blue for visibility.

<section id="code">
<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'b', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

</code></pre>

<figure>
          <img
            src="https://raw.githubusercontent.com/Zboyan/labreports/main/mfpic1.png"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Experimental Code Set #1:
	-The same triangle is now generated with random colors by the same method.
	-A list called colors is created with 50000 elements initialized as 0 in order to store colors.
	-Later on, colors[0] followed by three randoms creates a tuple with three random values in RGB format.
	-The decimal is a floatbetween 0 and 1 sets the intensity of Red, Green, and Blue components.
	-Each point gets it sown random color and that color is stored in colors[i] in the loop.
	-The colors are plotted easily with the scatter function having color=colors as a list.


<pre><code>

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
colors = [0]*iterates

x[0], y[0] = random(), random()
colors[0] = (random(), random(), random())  # RGB random color

for i in range(1, iterates):
    k = randint(0, 2)
    x[i], y[i] = midpoint(vertices[k], (x[i-1], y[i-1]))
    colors[i] = (random(), random(), random())  # New random color for each point

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=0.1)
plt.title('Sierpinski Triangle with Random Colors')
plt.axis('equal')
plt.show()

	
</code></pre>

<figure>
          <img
            src="https://raw.githubusercontent.com/Zboyan/labreports/main/mfpic2.png"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Experimental Code Set #2:
	-A Koch Snowflake with random colors is now created by this point-by-point plotting method.
	-The build began with an equilateral triangle, then it divided into 3 equal parts, an equilateral bump was placed on the middle third, then it was removed.
	-The process is then repeated for a certain number of iterations.
	-The Koch function specifically features two points and recursion levels.
	-There is a stopping condition, so once the recursion is 0 a straight line between points is returned.
	-The else case uses the two points p1 and p2 converted into arrays to allow for easy math operation.
	-Points that are 1/3 and 2/3's along the line are then found in order to form the bump.
	-The peak point is found by rotating the vector between 1/3 and 2/3's by 60 degrees.
	-Recursion divide splits the line into 4 new sections: p1->1/3, 1/3->peak, peak->2/3, and 2/3->p2 and Koch_curve is called for each.
	-Doubles or duplicates are prevented by subtracting 1.
	-The initial triangle has (0,0), (1,0), and (.5, np.sqrt(3)/2) to make an equilateral triangle.
	-The sides are then formed between each set and double counting is prevented.
	-A giant list is used to collect all points.
	-x and y coordinates are extracted into two lists for plotting.
	-Random colors are generated and points are plotted.

<pre><code>

import matplotlib.pyplot as plt
from random import random
import numpy as np

def koch_curve(p1, p2, level):
    if level == 0:
        return [p1, p2]
    else:
        p1 = np.array(p1)
        p2 = np.array(p2)
        # Points dividing into thirds
        one_third = p1 + (p2 - p1) / 3
        two_third = p1 + 2*(p2 - p1) / 3
        
        # Peak point
        angle = np.pi / 3  # 60 degrees
        direction = two_third - one_third
        peak = one_third + np.array([
            np.cos(angle) * direction[0] - np.sin(angle) * direction[1],
            np.sin(angle) * direction[0] + np.cos(angle) * direction[1]
        ])
        
        # Recursively subdivide
        return (koch_curve(p1, one_third, level-1)[:-1] +
                koch_curve(one_third, peak, level-1)[:-1] +
                koch_curve(peak, two_third, level-1)[:-1] +
                koch_curve(two_third, p2, level-1))

# Initial equilateral triangle points
p1 = (0, 0)
p2 = (1, 0)
p3 = (0.5, np.sqrt(3)/2)

level = 4  # How many iterations (more = finer snowflake)

# Build the sides
side1 = koch_curve(p1, p2, level)[:-1]
side2 = koch_curve(p2, p3, level)[:-1]
side3 = koch_curve(p3, p1, level)

# Gather all points
points = side1 + side2 + side3

# Extract x and y
x = [pt[0] for pt in points]
y = [pt[1] for pt in points]

# Create random colors per point
colors = [(random(), random(), random()) for _ in range(len(points))]

# Plotting
plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=1)
plt.title('Koch Snowflake with Random Colors')
plt.axis('equal')
plt.axis('off')
plt.show()
	
</code></pre>

<figure>
          <img
            src="https://raw.githubusercontent.com/Zboyan/labreports/main/mfpic3.png"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>
		
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          ANALYSIS ANALYSIS ANALYSIS
        </p>




        <figure>
          <img
            src="https://raw.githubusercontent.com/Zboyan/labreports/main/mfpic3.png"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>


<h2>Part 1: TOPIC</h2>





</section>

    
	    



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
        OVERALL CONCLUSION HERE
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
