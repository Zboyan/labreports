<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>

<body id="top">



  <header>
    <h1>Fractal Geometry <br> Lab Report : Final Module</h1>
    <p class="author">
      [Courteney Zboyan] <br />
      [4/24/25]
  </header>
</body>


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
	<h2>Intro</h2>
        <p>
          INTRODUCTION INTRODUCTION

		

		
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->

Sample Code Set #1: Siepinski Triangle
	-This code generates a Siepinski Triangle using the Chaos Game Method.
	-Matplotlib is used to plot the points and numpy is for mathematical operations.
	-Random and randint generate initial points and vertex randomly.
	-A function is defined to calculate a midpoint between two established points of P and Q.
	-The vertices of a triangle are defined as (0,0), (4,0), and (2, 2*np.sqrt(3)) to make it equilateral.
	-The process is initialized with 50000 iterations to make that many points.
	-Each coordinate will have its points stored.
	-The starting point is set to a random location in the plot area.
	-One of the three vertices is chosen, then the midpoint between that and the previous point is found. 
	-The new point becomes the midpoint and the process repeats 50000 times.
	-The points are then plotted in an 8x8 area for the figure.
	-They are set to size 0.1 and blue for visibility.

<section id="code">
<pre><code class="language-python">

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'b', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic1.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Experimental Code Set #1:
	-The same triangle is now generated with random colors by the same method.
	-A list called colors is created with 50000 elements initialized as 0 in order to store colors.
	-Later on, colors[0] followed by three randoms creates a tuple with three random values in RGB format.
	-The decimal is a floatbetween 0 and 1 sets the intensity of Red, Green, and Blue components.
	-Each point gets its own random color and that color is stored in colors[i] in the loop.
	-The colors are plotted easily with the scatter function having color=colors as a list.


<pre><code>

import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
colors = [0]*iterates

x[0], y[0] = random(), random()
colors[0] = (random(), random(), random())  # RGB random color

for i in range(1, iterates):
    k = randint(0, 2)
    x[i], y[i] = midpoint(vertices[k], (x[i-1], y[i-1]))
    colors[i] = (random(), random(), random())  # New random color for each point

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=0.1)
plt.title('Sierpinski Triangle with Random Colors')
plt.axis('equal')
plt.show()

	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic2.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Experimental Code Set #2: Koch Snowflake
	-A Koch Snowflake with random colors is now created by this point-by-point plotting method.
	-The build began with an equilateral triangle, then it divided into 3 equal parts, an equilateral bump was placed on the middle third, then it was removed.
	-The process is then repeated for a certain number of iterations.
	-The Koch function specifically features two points and recursion levels.
	-There is a stopping condition, so once the recursion is 0 a straight line between points is returned.
	-The else case uses the two points p1 and p2 converted into arrays to allow for easy math operation.
	-Points that are 1/3 and 2/3's along the line are then found in order to form the bump.
	-The peak point is found by rotating the vector between 1/3 and 2/3's by 60 degrees.
	-Recursion divide splits the line into 4 new sections: p1->1/3, 1/3->peak, peak->2/3, and 2/3->p2 and Koch_curve is called for each.
	-Doubles or duplicates are prevented by subtracting 1.
	-The initial triangle has (0,0), (1,0), and (.5, np.sqrt(3)/2) to make an equilateral triangle.
	-The sides are then formed between each set and double counting is prevented.
	-A giant list is used to collect all points.
	-x and y coordinates are extracted into two lists for plotting.
	-Random colors are generated and points are plotted.

<pre><code>

import matplotlib.pyplot as plt
from random import random
import numpy as np

def koch_curve(p1, p2, level):
    if level == 0:
        return [p1, p2]
    else:
        p1 = np.array(p1)
        p2 = np.array(p2)
        # Points dividing into thirds
        one_third = p1 + (p2 - p1) / 3
        two_third = p1 + 2*(p2 - p1) / 3
        
        # Peak point
        angle = np.pi / 3  # 60 degrees
        direction = two_third - one_third
        peak = one_third + np.array([
            np.cos(angle) * direction[0] - np.sin(angle) * direction[1],
            np.sin(angle) * direction[0] + np.cos(angle) * direction[1]
        ])
        
        # Recursively subdivide
        return (koch_curve(p1, one_third, level-1)[:-1] +
                koch_curve(one_third, peak, level-1)[:-1] +
                koch_curve(peak, two_third, level-1)[:-1] +
                koch_curve(two_third, p2, level-1))

# Initial equilateral triangle points
p1 = (0, 0)
p2 = (1, 0)
p3 = (0.5, np.sqrt(3)/2)

level = 4  # How many iterations (more = finer snowflake)

# Build the sides
side1 = koch_curve(p1, p2, level)[:-1]
side2 = koch_curve(p2, p3, level)[:-1]
side3 = koch_curve(p3, p1, level)

# Gather all points
points = side1 + side2 + side3

# Extract x and y
x = [pt[0] for pt in points]
y = [pt[1] for pt in points]

# Create random colors per point
colors = [(random(), random(), random()) for _ in range(len(points))]

# Plotting
plt.figure(figsize=(8, 8))
plt.scatter(x, y, color=colors, s=1)
plt.title('Koch Snowflake with Random Colors')
plt.axis('equal')
plt.axis('off')
plt.show()
	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic3.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
</figure>

Sample Code Set #2: Barnsley Fern
	-The Barnsley Fern is generated by iteration with Affine transformations and probabilities.
	-The method is specifically called IFS - Iterated Function System.
	-The random and matplotlib libraries are used to randomly select which transformation to apply and plot points.
	-There are 4 transformation functions of f1, f2, f3, and f4 of the affine variety.
	-These functions each take mathematical operations that modify points in the 2D plane and return the new coordinates.
	-The first function is a vertical shrink which scales the y values by .16, especially pushing the points straight down and mostly contributes to the fern shape at the bottom.
	-The second function scales and rotates the points with .85 and adds a 1.6 vertical offset to generate the dense fronds of the fern.
	-The third function acts like the second, but uses different scaling coefficients to create the smaller branches that extend diagonally.
	-The fourth function is like the previous two, but with different scaling coefficients and less vertical offset, it creates a slight slant to some fronds.
	-The probabilities for each function are displayed as .01, .85, .07, .07 for f1, f2, f3, and f4 respectively; as any valid probability model, they sum to 1.
	-The Barnsley Fern function is now defined with intial condition (0,0) and 100000 iterations.
	-The affine function used is based on a proability from random choice number between 0 and 1.
	-The points are then appended to the points list.
	-The zip(*fern_points) splits the coordinate into two lists of x and y each.
	-The scatter function plots the points in green with size 0.1 on a 6x10 grid space.
	

<pre><code>

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='green')
plt.title('Barnsley Fern')
plt.show()
	
</code></pre>

<figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic4.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>

Experimental Code Set#3:
	-The same fern is now generated with random colors by the same method.
	-A list called colors is created with 100000 elements initialized as 0 in order to store colors.
	-Later on, colors[0] followed by three randoms creates a tuple with three random values in RGB format.
	-The decimal is a floatbetween 0 and 1 sets the intensity of Red, Green, and Blue components.
	-Each point gets its own random color and that color is stored in colors[i] in the loop.
	-The colors are plotted easily with the scatter function having color=fern_colors as a list.

	<pre><code>

import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function with colors
def barnsley_fern_colored(iterations):
    x, y = 0, 0
    points = []
    colors = []

    for _ in range(iterations):
        rand = random.random()
        if rand < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

        # Generate a random RGB color for each point
        colors.append((random.random(), random.random(), random.random()))

    return points, colors

# Generate points and colors
iterations = 100000
fern_points, fern_colors = barnsley_fern_colored(iterations)

# Extract x and y values
x_vals, y_vals = zip(*fern_points)

# Plotting
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color=fern_colors)
plt.title('Colorful Barnsley Fern')
plt.axis('off')  # Optional: turn off the axis for a cleaner look
plt.show()

	</code></pre>

	 <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic5.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="800"
            loading="lazy"
          />
        </figure>
	
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          ANALYSIS ANALYSIS ANALYSIS
        </p>




        <figure>
          <img
            src="https://github.com/Zboyan/labreports/blob/main/mfpic1.png?raw=true"
            alt="ADD AN IMAGE HERE"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>


</section>

    
	    



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
     	<h2>Conclusion</h2>
        <p>
        OVERALL CONCLUSION HERE
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
